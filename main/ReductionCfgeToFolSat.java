import java.util.ArrayList;
import java.util.List;
import java.util.Objects;
import java.util.Set;

public class ReductionCfgeToFolSat extends TPTPWriter{

    public String cfgeToFolSat(ContextfreeGrammar C1, ContextfreeGrammar C2){
        return encodingWordStructure(C1.getAlphabet(), C2.getAlphabet()) + encodingCYKTable(C1.getVariables(), C1.getRules()) + encodingCYKTable(C2.getVariables(), C2.getRules()) + encodingGrammarInequivalence(C1.getStartVariables(), C2.getStartVariables());
    }

    /**
     * sub-formula: every position of the searched-for word contains exactly one letter
     * */
    public String encodingWordStructure(Set<String> alphabetC1, Set<String> alphabetC2){
        // a set contains no element twice; all distinct letters from both alphabets are included
        alphabetC1.addAll(alphabetC2);
        // conversion to list, so it's possible to question element index
        List<String> alphabet = new ArrayList<>(alphabetC1);

        if (alphabet.isEmpty()) throw new IllegalStateException("both CFG alphabets are empty!");

        String folFormula = "( ";
        folFormula += forAll("X") + "( ";

        for (String sigma : alphabet){
            if (!Objects.equals(alphabet.get(0), sigma)){
                folFormula += or();
            }

            folFormula += "( Q_" + sigma + "(X)";

            List<String> alphabetWithoutSigma = new ArrayList<>(alphabet);
            alphabetWithoutSigma.remove(sigma);

            for (String letterNotSigma : alphabetWithoutSigma) {
                folFormula += and() + not() + "Q_" + letterNotSigma + "(X)";
            }
            folFormula += " )";
            alphabetWithoutSigma.add(sigma);
        }
        folFormula += " )";
        return folFormula + " )";
    }

    /**
     * sub-formula: representing the CYK Table
     * */
    private String encodingCYKTable(Set<String> variables, Set<String> rules){
        String folFormulaSubwordLengthOne = subwordsLengthOne(variables, rules);
        String folFormulaSubwordGreaterOne = subwordsGreaterOne(variables, rules);

        return "(" + forAll("X") + forAll("Y") + folFormulaSubwordLengthOne + or() + folFormulaSubwordGreaterOne + ")";
    }

    /**
     * sub-formula: CYK Table entries where sub-word has length 1 ie. V =>* w iff V -> sigma
     * */
    private String subwordsLengthOne(Set<String> variables, Set<String> rules){
        String folFormula = "";
        return folFormula;
    }

    /**
     * sub-formula: CYK Table entries where sub-word has length > 1 ie. V =>* w iff V -> AB
     * */
    private String subwordsGreaterOne(Set<String> variables, Set<String> rules){
        String folFormula = "";
        return folFormula;
    }

    /**
     * sub-formula: w is generated by C1 iff it is not generated by C2
     * */
    private String encodingGrammarInequivalence(Set<String> startVariablesC1, Set<String> startVariablesC2){
        return "(" + wordIsGenerated(startVariablesC1) + equivalent() + not() + wordIsGenerated(startVariablesC2) + ")";
    }

    /**
     * sub-formula: w is generated by C
     * */
    private String wordIsGenerated(Set<String> startVariables){
        String folFormula = "";
        return folFormula;
    }

}
