import java.util.ArrayList;
import java.util.List;
import java.util.Objects;
import java.util.Set;

public class ReductionCfgeToFolSat extends TPTPWriter{

    protected String reduce(ContextfreeGrammar C1, ContextfreeGrammar C2){
        return encodingWordStructure(C1, C2) + encodingCYKTable(C1) + encodingCYKTable(C2) + encodingGrammarInequivalence(C1, C2);
    }

    /**
     * sub-formula: every position of the searched-for word contains exactly one letter
     * */
    protected String encodingWordStructure(ContextfreeGrammar C1, ContextfreeGrammar C2){

        Set<String> alphabetC1 = C1.getAlphabet();

        // a set contains no element twice; all distinct letters from both alphabets are included
        alphabetC1.addAll(C2.getAlphabet());

        // conversion to list, so it's possible to question element index
        List<String> alphabet = new ArrayList<>(alphabetC1);

        if (alphabet.isEmpty()) throw new IllegalStateException("both CFG alphabets are empty!");

        String folFormula = "( ";
        folFormula += forAll("X") + "( ";

        for (String sigma : alphabet){
            if (!Objects.equals(alphabet.get(0), sigma)){
                folFormula += or();
            }

            folFormula += "( Q_" + sigma + "(X)";

            List<String> alphabetWithoutSigma = new ArrayList<>(alphabet);
            alphabetWithoutSigma.remove(sigma);

            for (String letterNotSigma : alphabetWithoutSigma) {
                folFormula += and() + not() + "Q_" + letterNotSigma + "(X)";
            }
            folFormula += " )";
            alphabetWithoutSigma.add(sigma);
        }
        folFormula += " )";
        return folFormula + " )";
    }

    /**
     * sub-formula: representing the CYK Table
     * */
    protected String encodingCYKTable(ContextfreeGrammar CFG){
        Set<String> variables = CFG.getVariables();
        Set<String> rules = CFG.getRules();
        String name = CFG.getName();

        return "(" + forAll("X") + forAll("Y") + subwordsLengthOne(variables, rules, name) + or() + subwordsGreaterOne(variables, rules, name) + ")";
    }

    /**
     * sub-formula: CYK Table entries where sub-word has length 1 ie. V =>* w iff V -> sigma
     * */
    public String subwordsLengthOne(Set<String> variables, Set<String> rules, String name){

        if (variables.isEmpty()) throw new IllegalStateException("CFG variables is empty!");
        if (rules.isEmpty()) throw new IllegalStateException("CFG variables is empty!");

        List<String> vars = new ArrayList<>(variables);
        List<String> productions = new ArrayList<>(rules);

        // if position X == position Y
        String folFormula = "( X leq(Y)" + and() + "Y leq(X)" + implies() + "( ";

        for (String var : vars){
            if (!Objects.equals(vars.get(0), var)){
                folFormula += and();
            }

            folFormula += "( " + name + "_T_" + var + "(X, Y)" + equivalent();

            List<String> terminalProductionsFromVar = new ArrayList<>();
            for (String rule : productions){
                if (rule.length() == 2){
                    if (Objects.equals(rule.substring(0, 1), var)){
                        terminalProductionsFromVar.add(rule);
                    }
                }
            }

            folFormula += "( ";

            for (String rule : terminalProductionsFromVar){
                if (!Objects.equals(terminalProductionsFromVar.get(0), rule)){
                    folFormula += or();
                }
                folFormula += "Q_" + rule.charAt(1) + "(X)";
            }

            folFormula += " ) )";

            terminalProductionsFromVar.clear();

        }

        folFormula += " ) )";

        return folFormula;
    }

    /**
     * sub-formula: CYK Table entries where sub-word has length > 1 ie. V =>* w iff V -> AB
     * */
    private String subwordsGreaterOne(Set<String> variables, Set<String> rules, String name){
        String folFormula = "";
        return folFormula;
    }

    /**
     * sub-formula: w is generated by C1 iff it is not generated by C2
     * */
    protected String encodingGrammarInequivalence( ContextfreeGrammar C1, ContextfreeGrammar C2){
        return "(" + wordIsGenerated(C1.getStartVariables()) + equivalent() + not() + wordIsGenerated(C2.getStartVariables()) + ")";
    }

    /**
     * sub-formula: w is generated by C
     * */
    private String wordIsGenerated(Set<String> startVariables){
        String folFormula = "";
        return folFormula;
    }

}
